---
title: C++11中的auto关键字
date: 2018-05-25 16:42:05
tags: [auto]
categories: c++
---

本文介绍了auto关键字在C++11(及C++14)中的类型推导规则和使用场景。有些地方它不可或缺，但也要避免滥用。

<!-- more -->

# 类型推导 (1)

## 引用和修饰符剥除 (1.1)

对于：
```cpp
auto a = {expression};
```

* 如果{expression}有引用(无论是左值引用还是右值引用)，则引用修饰符(&或者&&)被忽略；
* 如果{expression}有top-level的const/volatile修饰符，则const/volatile被忽略；

例如：
```cpp
int i = 0;
const int & cri = x;
auto a = cri; // type of a is "int", because the lvalue reference and the const are ignored;

const int && crvref = 10;
auto a1 = crvref;  // type of a1 is "int", because the rvalue reference and the const are ignored;

int x = 42;
const int * p1 = &x;
auto p2 = p1; // const is not ignored, because it is not at top-level;
*p2 = 43;     // error: p2 is const int*
```

也就是说，初始化表达式的引用(无论是左值引用还是右值引用)是要被剥除(stripping)的；而const/volatile等关键字，若不影响语义，则剥除。如果你就想要引用以及const呢？见下文。

## auto& (1.2)

**语法：**
```cpp
auto& ra = {expression};
```

**规则：**
* 先对{expression}进行引用剥除(stripping)；
* {expression}只能是左值表达式；
* ra是{expression}的左值引用；
* {expression}若有const修饰符，则不能被剥除，因为若剥除const，则常量表达式能被修改了；

**举例：**
```cpp
//必须引用左值；
auto& rc1 = 4; //error: invalid initialization of non-const reference of type int& from an rvalue of type int

//加上const，可以引用右值；
const auto& rc2 = 4;

const int c = 0;
auto& rc3 = c;

//rc3的类型是"const int&"；因为const不能被剥除，否则c就不是常量表达式了；
rc3 = 1; //error: assignment of read-only reference rc3
```

## auto&& (1.3)

**语法：**
```cpp
auto&& rra = {expression};
```

**规则：**
* 先对{expression}进行引用剥除(stripping)；
* {expression}可以是左值表达式，也可以是右值表达式；
* 如果{expression}是左值表达式，则rra是它的左值引用；
* 如果{expression}是右值表达式，则rra是它的右值引用；

**举例：**
```cpp
int i = 42;
auto&& ri_1 = i;  //ri_1的类型是"int&"
auto&& ri_2 = 42; //ri_2的类型是"int&&"

const int j = 3;
auto&& ri_3 = j;  //ri_3是左值引用，需要保留const，故"const int&"
ri_3 = 5;  //error: assignment of read-only reference ri_3
```

**重点1**：

虽然"&&"很容易让人想起**右值引用**，但它不是！你给它左值，它表现出左值引用的行为；给它右值，它表现出右值引用的行为。这种灵活的引用，叫作**通用引用**。见[C++11中的通用引用](http://www.yuanguohuo.com/2018/05/25/cpp11-universal-ref/)。

**重点2**:

```cpp
char&& var1 = 'A';
auto&& var2 = var1;

std::cout << (void*)&var1 << std::endl;
std::cout << (void*)&var2 << std::endl;

var = 'B';

std::cout << var1 << std::endl;
std::cout << var2 << std::endl;
```

var1的类型是右值引用(char&&)，但它自身是一个左值，关于这一点，见[C++11中的右值引用](http://www.yuanguohuo.com/2018/05/25/cpp11-rvalue-ref/)。因为var2是一个通用引用，并且我们用左值var1来初始化它，所以，最终var2等价于一个左值引用(char&)。中间两行打印的地址是一样的(因为它们引用同一个变量)；最后两行都输出'B'(这个变量被改写成'B')。这一点，我们在[C++11中的通用引用](http://www.yuanguohuo.com/2018/05/25/cpp11-universal-ref/)中还会看到。

# 使用场景 (2)

## 基础用法 (2.1)

```cpp
std::vector<int> vect;
// ...
for(std::vector<int>::iterator it = vect.begin(); it != vect.end(); ++it)
{
  std::cin >> *it;
}
```
可以更简便的写作：

```cpp
std::vector<int> vect;
// ...
for(auto it = vect.begin(); it != vect.end(); ++it)
{
  std::cin >> *it;
}
```

变量it和vect.begin()的类型是完全一样的，因此，编译器可以推断出它的类型，不必麻烦程序员每次都重写一遍。还有其他类似的使用方式，其目的是让编译器来推断类型，程序员省去一些打字的工作（毕竟，写个auto是很快捷的）。

然而，本人不喜欢这样的用法，理由是（本人的拙见，欢迎持不同意见的同学来讨论）：

* 打字在编程中占的工作量有限，在这方面节省一点时间，能提高多少效率呢？
* 程序员在写代码的时候，实际上是很清楚每个变量的类型的，这个时候为了节省一点打字工作而简单的写个auto，维护（阅读）代码的人可能需要自己去推导变量的类型。而这个推导成本，应该远远大于打字节省的工作量吧！
* 即使对于上面的例子（for循环遍历vector），明确的写出vector< int >::iterator（或者vector< int >::const_iterator），也可以让程序员熟悉vector的使用方式，甚至能够使程序员联想起vector以及iterator的实现（类似的，map及其iterator的实现……）。

所以，本人认为，仅仅为了编码便利，我们不应该使用auto；它应该出现在有正当需求的地方，见下文。

## 无法确定类型的地方 (2.2)

比如，我们写这样一个模板函数：

```cpp
template<typename T, typename S>
void foo(T lhs, S rhs)
{
  auto prod = lhs * rhs;
  //...
}
```
C++11以前，表达式lhs*rhs的类型无法确定（若lhs都是int，则为int；若一个int一个double则为double；另外，T和S还可能是程序员自定义的类——重载了乘法运算符——那么结果类型就有无限多了），我们该如何写prod的类型呢？

C++11有两种途径来定义prod的类型，其一就是如上所示的auto。另一个是decltype，我在这一篇里介绍。

## Function return type deduction in C++14 (2.3)

C++11中提供了一个特性：lambda函数的返回类型可以由return表达式的类型推定。C++14把这一特性扩展到所有函数：也就是，函数的返回类型定义为auto （注意，后面没有 -> decltype（），若有，则是C++11的trailing return type语法）。例如：

```cpp
auto add(int a, int b)
{
    return a + b;
}
```
和前文(基础用法)类似，编译器可以根据return语句推断出函数的类型。同样，我不喜欢这样的写法，理由也类似。除此之外，它还有一些限制：

* 限制1： 若有多个返回语句，则各个返回表达式的类型必须一样；
* 限制2：可以前置声明，但是定义之前是不能使用的（那前置声明有什么用呢？）；
* 限制3： 返回auto的函数递归时， 递归调用前，至少有一个return 语句。例如：

```cpp
auto Correct(int i)
{
  if (i == 1)
    return i;               // return type deduced as int
  else
    return Correct(i-1)+i;  // ok to call it now
}

auto Wrong(int i)
{
  if (i != 1)
    return Wrong(i-1)+i;  // Too soon to call this. No prior return statement.
  else
    return i;             // return type deduced as int
}
```

## trailing return type (2.4)
这是decltype的使用方式，auto只是配合一下。见[C++11中的decltype关键字](http://www.yuanguohuo.com/2018/05/26/cpp11-decltype/)。

## Alternate type deduction on declaration (2.5)

这是auto和decltype结合的使用方式。见[C++11中的decltype关键字](http://www.yuanguohuo.com/2018/05/26/cpp11-decltype/)。


# 小结 (3)
本文介绍了C++11引入的auto关键字，包括类型推导规则、使用场景。和它类似、又相关的decltype，将在[C++11中的decltype关键字](http://www.yuanguohuo.com/2018/05/26/cpp11-decltype/)中介绍。

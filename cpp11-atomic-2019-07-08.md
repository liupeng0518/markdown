---
title: C++11中的atomic
date: 2019-07-08 20:33:09
tags: [atomic]
categories: c++
---

首先简单介绍`g++ (GCC) 4.8.5`的atomic实现。然后介绍atomic的使用(和实现无关)。

<!-- more -->

# 实现简介 (1)

注意，这里讲的实现是针对`g++ (GCC) 4.8.5`的，可能和其他版本不完全一致。后续介绍atomic的使用时，和具体实现无关。

## `struct __atomic_flag_base` (1.1)

```cpp
  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };
```

`__atomic_flag_data_type`是一个bool或者 unsigned char：

```cpp
#if __GCC_ATOMIC_TEST_AND_SET_TRUEVAL == 1
    typedef bool __atomic_flag_data_type;
#else
    typedef unsigned char __atomic_flag_data_type;
#endif
```

## `struct atomic_flag` (1.2)

```cpp
  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;

    // Conversion to ATOMIC_FLAG_INIT.
    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }
    ...
  };
```
主要是`test_and_set`和`clear`操作的实现。

## `template<typename _ITp> struct __atomic_base` (1.3)

```cpp
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp  __int_type;
  
      __int_type  _M_i;
  
    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;
  
      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
      ...
    };
```

这个模板是为基础类型提供的，基础类型包括：

```cpp
  char
  signed char
  unsigned char
  short
  unsigned short
  int
  unsigned int
  long
  unsigned long
  long long
  unsigned long long
  char16_t
  char32_t
  wchar_t
```

里面重载了这些基础类型支持的`++`, `--`, `+=`, `-=`等操作。

```cpp
  typedef __atomic_base<char>                      atomic_char;
  typedef __atomic_base<signed char>               atomic_schar;
  typedef __atomic_base<unsigned char>             atomic_uchar;
  typedef __atomic_base<short>                     atomic_short;
  typedef __atomic_base<unsigned short>            atomic_ushort;
  typedef __atomic_base<int>                       atomic_int;
  typedef __atomic_base<unsigned int>              atomic_uint;
  typedef __atomic_base<long>                      atomic_long;
  typedef __atomic_base<unsigned long>             atomic_ulong;
  typedef __atomic_base<long long>                 atomic_llong;
  typedef __atomic_base<unsigned long long>        atomic_ullong;
  typedef __atomic_base<wchar_t>                   atomic_wchar_t;
  ...
```

## `struct atomic_bool` (1.4)

bool不支持`++`, `--`, `+=`, `-=`等操作，所以，bool是通过单独的一个class实现的。一个`struct atomic_bool`组合(而不是继承)一个`__atomic_base<bool>`，除去了不支持的加减操作。

```cpp
  struct atomic_bool
  {
  private:
    __atomic_base<bool> _M_base;

  public:
    atomic_bool() noexcept = default;
    ~atomic_bool() noexcept = default;
    atomic_bool(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) volatile = delete;

    constexpr atomic_bool(bool __i) noexcept : _M_base(__i) { }
    ...
  };
```

## `template<typename _PTp> struct __atomic_base<_PTp*>` (1.5)

针对指针类型的偏特化。

## `template<typename _Tp> struct atomic` (1.6)

```cpp
  template<typename _Tp>
    struct atomic
    {
    private:
      _Tp _M_i;
  
    public:
      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;
  
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
      ...
    };
```

这个类不是基于`__atomic_base`实现的，是一个全新的实现，主要用于: 

* 自定义类型；例如`class Foo {...}; atomic<Foo>;`；
* 特化以支持基础类型(见1.7, 1.8, 1.9节)；

## `template<typename _Tp> struct atomic<_Tp*>` (1.7)

针对指针类型的偏特化；是基于`__atomic_base`实现的。

```cpp
  template<typename _Tp>
    struct atomic<_Tp*>
    {
      typedef _Tp*          __pointer_type;
      typedef __atomic_base<_Tp*>   __base_type;
      __base_type           _M_b;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) { }
      ...
    };
```

## `template<> struct atomic<bool> : public atomic_bool` (1.8)

针对bool类型的特化；是继承`atomic_bool`实现的；

```cpp
  /// Explicit specialization for bool.
  template<>
    struct atomic<bool> : public atomic_bool
    {
      typedef bool          __integral_type;
      typedef atomic_bool       __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };
```

## `template<> struct atomic<char> : public atomic_char` (1.9)

针对bool类型的特化；是继承`atomic_char`实现的；

```cpp
  /// Explicit specialization for char.
  template<>
    struct atomic<char> : public atomic_char
    {
      typedef char          __integral_type;
      typedef atomic_char       __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };
```

## 关系图 (1.10)

unsigned char, short, int, long, long long ... 等都和char一样，不一一列出。最后以一张图表示它们的关系：![类关系图](atomic_classes.jpg)

程序员应该使用绿色部分的类(模板)。`atomic_flag`相当于一个自旋锁；`atomic<bool>`, `atomic<char>`, `atomic<short>`, `atomic<int>`等是基础类型的atomic版；`atomic<_Tp*>`是指针类型的atomic版；`atomic<Foo>`是自定义类型的atomic版。
